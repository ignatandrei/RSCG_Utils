using System.Collections.Concurrent;
@inherits RazorBlade.HtmlTemplate<SaveMemo>

@{
    string nameDict = "__cache_" + Model.fullName();
    string separatedTypes = string.Join(",", Model.typeParameters);
    string separatedArguments = string.Join(",", Model.nameParameters);
    string typeAndNameArgs = string.Join(",", Model.typeAndNameParameters);
    string keyDict = Model.HasArguments ? $"Tuple<{separatedTypes}>" : "string";
    string declDict = $"System.Collections.Concurrent.ConcurrentDictionary<{keyDict} , {Model.returnTypeNoTask}> {nameDict} =new System.Collections.Concurrent.ConcurrentDictionary<{keyDict}, {Model.returnTypeNoTask}>();";
    string Tuple2Args = string.Join(",",Model.nameParameters.Select((it, nr) => $"args.Item{nr+1}"));
    string asyncText = Model.IsTask ? "async" : "";
    string awaitText = Model.IsTask ? "await" : "";
    string keyFunc = Model.HasArguments ? $"Tuple.Create({separatedArguments})" : "string.Empty"; 
}
//this is auto-generated by a tool
@if(!string.IsNullOrWhiteSpace(Model.nameSpaceName))
{
    <text>namespace @Model.nameSpaceName;</text>
}

partial @Model.nameDefinition @Model.className 
{
    
    @Html.Raw(declDict)
    //@Model.IsTask 
    public @asyncText @Html.Raw(Model.returnType) @Model.nameMethodNew (@typeAndNameArgs ){
        var key= @keyFunc;
        @Html.Raw($"if ({nameDict}.TryGetValue(key, out var result)) return result;")
        //Console.WriteLine($"not in cache, calculating {key}");
        var data= @Html.Raw($"{awaitText} __wrap_{Model.nameMethodNew}(key)");
        return @Html.Raw($"{nameDict}.GetOrAdd(key,data);" )
    }
    public @asyncText @Html.Raw(Model.returnType) __wrap_@Model.nameMethodNew (@Html.Raw(keyDict) args){
        return @awaitText @Html.Raw(Model.nameMethodOriginal) (@Tuple2Args);
    }
    
}
